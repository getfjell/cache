# IndexedDB Storage Key Validation Fix

## Problem Statement

Production environments were experiencing repeated errors:

```
DataError: Failed to execute 'get' on 'IDBObjectStore': No key or key range specified.
```

This error occurred dozens of times during cache initialization, causing the cache system to fall back to memory-only mode. When that happened:
- IndexedDB initialization would fail completely
- Cache would operate in memory-only mode
- Data wouldn't persist across page navigation
- User would see blank screens when navigating between pages (e.g., Geometry → Construction tab)

## Root Cause Analysis

The issue was in the `AsyncIndexDBCacheMap.getStorageKey()` method. The storage key is generated by hashing the cache key using `normalizedHashFunction()`.

**The problem:** If the hash function returned an invalid value (empty string, null, or undefined), subsequent calls to IndexedDB operations like `store.get(storageKey)` would fail with "No key or key range specified" because IndexedDB requires a valid key.

### Why It Happened

1. `normalizedHashFunction` could return an empty string in edge cases
2. `store.get()`, `store.put()`, etc. require a valid key parameter
3. IndexedDB strictly validates keys and rejects empty/null values
4. Without proper validation, these invalid keys would reach IndexedDB
5. IndexedDB would throw the "No key or key range specified" error
6. The entire initialization would fail and fall back to memory-only mode

## Solution

Added comprehensive storage key validation and error handling at multiple layers:

### 1. **Storage Key Validation** (`getStorageKey()`)
```typescript
private getStorageKey(key: ComKey<S, L1, L2, L3, L4, L5> | PriKey<S>): string {
  const storageKey = this.normalizedHashFunction(key);
  if (!storageKey || typeof storageKey !== 'string' || storageKey.trim() === '') {
    logger.error('Invalid storage key generated from normalizedHashFunction', { key, storageKey });
    throw new Error(`Invalid storage key generated for key: ${JSON.stringify(key)}`);
  }
  return storageKey;
}
```

### 2. **Key Generation Try-Catch** in All Operations
```typescript
let storageKey: string;

try {
  storageKey = this.getStorageKey(key);
} catch (keyError) {
  logger.error('Failed to generate storage key', { key, error: keyError });
  return null;  // or throw, depending on operation
}
```

### 3. **Request-Level Error Handling**
```typescript
return new Promise((resolve, reject) => {
  try {
    const request = store.get(storageKey);  // Wrapped in try-catch
    request.onerror = () => { /* handle error */ };
    request.onsuccess = () => { /* handle success */ };
  } catch (requestError) {
    logger.error('Error creating IndexedDB request', { key, storageKey, error: requestError });
    reject(requestError);
  }
});
```

### 4. **Improved Logging**
- Added `storageKey` to error logs for debugging
- Clearer error messages distinguishing between key validation and request failures
- Traces show which operations failed and why

## Affected Methods

The validation and error handling was applied to these critical methods:
- `get()` - Read operations
- `getWithMetadata()` - Read with metadata
- `set()` - Write operations
- `includesKey()` - Key existence checks
- `delete()` - Delete operations

## Implementation Benefits

✅ **Prevents Invalid Keys** - Validation catches bad keys before they reach IndexedDB
✅ **Better Error Messages** - Developers can now see what went wrong
✅ **Graceful Degradation** - Operations return null/false instead of throwing
✅ **Easier Debugging** - Storage key is logged with errors
✅ **Catches Sync Errors** - Request-level try-catch handles synchronous errors

## Testing

The fix should be tested with:
1. Valid keys - should work as before
2. Malformed keys - should be caught and logged, not sent to IndexedDB
3. IndexedDB failure scenarios - operations should degrade gracefully
4. Production-like conditions - verify "No key or key range specified" errors are gone

## Related Changes

This fix is paired with:
- Re-enabling IndexedDB in non-reference caches (now safe with validation)
- Removing the memory-only mode workaround

The cache system will now:
- Use IndexedDB for persistent, fast access to cached data
- Validate keys before any IndexedDB operation
- Gracefully handle errors without crashing
- Prevent the "No key or key range specified" error entirely

## Performance Impact

- **Negligible overhead** - Validation is a simple string check
- **Actual improvement** - Successful IndexedDB operations are now more reliable
- **Better UX** - No more blank screens from failed cache initialization
